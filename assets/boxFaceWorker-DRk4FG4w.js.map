{"version":3,"file":"boxFaceWorker-DRk4FG4w.js","sources":["../src/boxFaceWorker.ts"],"sourcesContent":["// import { vec3 } from 'gl-matrix';\n\ntype vec3 = [number, number, number] | Float32Array;\nlet vec3: typeof import('gl-matrix').vec3;\n// Initialize gl-matrix\n(async () => {\n    const glMatrix = await import('gl-matrix');\n    vec3 = glMatrix.vec3;\n    // console.log(`[Worker ${self.name || 'unnamed'}] gl-matrix initialized`);\n})();\n\ninterface FaceData {\n    start: number[];\n    right: number[];\n    up: number[];\n    uvIndex: number[];\n    size: number[];\n    radius: number;\n    resolution: number;\n    faceIndex: number;\n    numVerticesPerFace: number;\n    numIndicesPerFace: number;\n}\n\nfunction grid(\n    start: vec3,\n    right: vec3,\n    up: vec3,\n    width: number,\n    height: number,\n    widthSteps: number,\n    heightSteps: number,\n    indices: Uint32Array, // data will be pushed to indices and positions\n    positions: Float32Array, // data will be pushed to positions\n    faceIndex: number,\n    numVerticesPerFace: number\n): void {\n\n    const offsetVertexIndex = faceIndex * numVerticesPerFace;\n    // Traverse the face.\n    let pa = vec3.create();\n    let pb = vec3.create();\n    let pc = vec3.create();\n    let pd = vec3.create();\n    for (let x = 0; x < widthSteps; x++) {\n        for (let y = 0; y < heightSteps; y++) {\n            // Lower left corner of this quad.\n            vec3.scaleAndAdd(pa, start, right, (width * x) / widthSteps);\n            vec3.scaleAndAdd(pa, pa, up, (height * y) / heightSteps);\n\n            // Lower right corner.\n            vec3.scaleAndAdd(pb, pa, right, width / widthSteps);\n\n            // Upper right corner.\n            vec3.scaleAndAdd(pc, pb, up, height / heightSteps);\n\n            // Upper left corner.\n            vec3.scaleAndAdd(pd, pa, up, height / heightSteps);\n\n            // Store the six vertices of the two triangles composing this quad.\n            //positions.push(pa, pb, pc, pa, pc, pd);\n            const localQuadIndex = (x * heightSteps + y);\n            const vertexIndex = localQuadIndex * 4;\n            const vertexIndexComponent = vertexIndex * 3;\n            positions[vertexIndexComponent + 0] = pa[0];\n            positions[vertexIndexComponent + 1] = pa[1];\n            positions[vertexIndexComponent + 2] = pa[2];\n\n            positions[vertexIndexComponent + 3] = pb[0];\n            positions[vertexIndexComponent + 4] = pb[1];\n            positions[vertexIndexComponent + 5] = pb[2];\n\n            positions[vertexIndexComponent + 6] = pc[0];\n            positions[vertexIndexComponent + 7] = pc[1];\n            positions[vertexIndexComponent + 8] = pc[2];\n\n            positions[vertexIndexComponent + 9] = pd[0];\n            positions[vertexIndexComponent + 10] = pd[1];\n            positions[vertexIndexComponent + 11] = pd[2];\n\n            const triangleIndex = localQuadIndex * 6;\n            indices[triangleIndex + 0] = offsetVertexIndex + vertexIndex + 0;\n            indices[triangleIndex + 1] = offsetVertexIndex + vertexIndex + 2;\n            indices[triangleIndex + 2] = offsetVertexIndex + vertexIndex + 1;\n            indices[triangleIndex + 3] = offsetVertexIndex + vertexIndex + 0;\n            indices[triangleIndex + 4] = offsetVertexIndex + vertexIndex + 3;\n            indices[triangleIndex + 5] = offsetVertexIndex + vertexIndex + 2;\n        }\n    }\n}\n\nfunction generateFaceGrid(\n    start: vec3,\n    right: vec3,\n    up: vec3,\n    size: vec3,\n    radius: number,\n    resolution: number,\n    positions: Float32Array,\n    normals: Float32Array,\n    tangents: Float32Array,\n    uvs: Float32Array,\n    indices: Uint32Array,\n    uvIndex: number[],\n    faceIndex: number\n): void {\n    // Copy the grid generation and vertex processing logic here\n    // This is the same code as in the original grid function and face processing\n    // but working with local arrays instead of global ones\n    // ...\n    const numVerticesPerFace = positions.length / 3;\n\n    const width = vec3.length(vec3.multiply(vec3.create(), right, size));\n    const height = vec3.length(vec3.multiply(vec3.create(), up, size));\n\n    // scale the start point to the size of the face\n    start = vec3.multiply(vec3.create(), start, size);\n    grid(start, right, up, width, height, resolution, resolution, indices, positions, faceIndex, numVerticesPerFace);\n\n    // Calculate face normal by crossing right and up vectors\n    // const faceNormal = vec3.cross(vec3.create(), face.right, face.up);\n    // vec3.normalize(faceNormal, faceNormal);\n    {\n        // Pre-allocate all temporary vectors outside the loop\n        const position = vec3.create();\n        const normal = vec3.create();\n        const tangent = vec3.create();\n        const bitangent = vec3.create();\n        const clamped = vec3.create();\n\n        // Pre-calculate size values used in bounds check\n        const sizeHalf = vec3.scale(vec3.create(), size, 0.5);\n        const boundMaxVec = vec3.subtract(vec3.create(), sizeHalf, [radius, radius, radius]);\n        const boundMinVec = vec3.negate(vec3.create(), boundMaxVec);\n\n        // Direct array access for better performance\n        for (let i = 0; i < numVerticesPerFace; i++) {\n            const indexPos = i * 3;\n            const indexUv = i * 2;\n            const indexTangent = i * 4;\n\n            // Load position directly from array\n            position[0] = positions[indexPos];\n            position[1] = positions[indexPos + 1];\n            position[2] = positions[indexPos + 2];\n\n            // Rounding edges\n            // Clamp position to bounds\n            // if (false) {\n            vec3.max(clamped, boundMinVec, position);\n            vec3.min(clamped, boundMaxVec, clamped);\n\n            // Calculate normal and update position\n            vec3.subtract(normal, position, clamped);\n            vec3.normalize(normal, normal);\n            vec3.scaleAndAdd(position, clamped, normal, radius);\n            // }\n            // End of rounding edges\n\n            // Write position back to array\n            positions[indexPos] = position[0];\n            positions[indexPos + 1] = position[1];\n            positions[indexPos + 2] = position[2];\n\n            // Calculate UVs directly\n            uvs[indexUv] = (position[uvIndex[0]] / size[uvIndex[0]]) + 0.5;\n            uvs[indexUv + 1] = (position[uvIndex[1]] / size[uvIndex[1]]) + 0.5;\n\n            // Write normal\n            normals[indexPos] = normal[0];\n            normals[indexPos + 1] = normal[1];\n            normals[indexPos + 2] = normal[2];\n\n            // Calculate tangent more efficiently\n            vec3.copy(tangent, right);\n            vec3.normalize(tangent, tangent);\n            const dot = vec3.dot(tangent, normal);\n            vec3.scaleAndAdd(tangent, tangent, normal, -dot);\n            vec3.normalize(tangent, tangent);\n\n            // Calculate handedness with fewer operations\n            vec3.cross(bitangent, normal, tangent);\n            const handedness = vec3.dot(bitangent, up) > 0 ? 1.0 : -1.0;\n\n            // Write tangent\n            tangents[indexTangent] = tangent[0];\n            tangents[indexTangent + 1] = tangent[1];\n            tangents[indexTangent + 2] = tangent[2];\n            tangents[indexTangent + 3] = handedness;\n        }\n    }\n}\n// Set up message handler\nself.onmessage = async (e: MessageEvent<FaceData>) => {\n\n    // Wait for gl-matrix to be initialized\n    while (!vec3) {\n        // console.log(`[Worker ${self.name || 'unnamed'}] Waiting for gl-matrix initialization...`);\n        await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    // console.log(`[Worker ${self.name || 'unnamed'}] Received message:`, {\n    //     faceIndex: e.data.faceIndex,\n    //     resolution: e.data.resolution,\n    //     numVerticesPerFace: e.data.numVerticesPerFace,\n    //     numIndicesPerFace: e.data.numIndicesPerFace\n    // });\n    const startTiming = performance.now();\n\n    const {\n        start,\n        right,\n        up,\n        uvIndex,\n        size,\n        radius,\n        resolution,\n        faceIndex,\n        numVerticesPerFace,\n        numIndicesPerFace } = e.data;\n\n\n    // Convert arrays back to vec3\n    const startVec = vec3.fromValues(start[0], start[1], start[2]);\n    const rightVec = vec3.fromValues(right[0], right[1], right[2]);\n    const upVec = vec3.fromValues(up[0], up[1], up[2]);\n    const sizeVec = vec3.fromValues(size[0], size[1], size[2]);\n\n    // Create arrays for this face\n    const positions = new Float32Array(numVerticesPerFace * 3);\n    const normals = new Float32Array(numVerticesPerFace * 3);\n    const tangents = new Float32Array(numVerticesPerFace * 4);\n    const uvs = new Float32Array(numVerticesPerFace * 2);\n    const indices = new Uint32Array(numIndicesPerFace);\n\n    // Generate grid for this face\n    generateFaceGrid(\n        startVec, rightVec, upVec,\n        sizeVec, radius, resolution,\n        positions, normals, tangents, uvs, indices,\n        uvIndex, faceIndex\n    );\n\n    const endTiming = performance.now();\n    const duration = (endTiming - startTiming).toFixed(2);\n    console.log(`Face generation time: ${duration} milliseconds`);\n\n    // Send the result back\n    self.postMessage({\n        faceIndex,\n        positions: positions,\n        normals: normals,\n        tangents: tangents,\n        uvs: uvs,\n        indices: indices\n    }, {\n        transfer: [\n            positions.buffer,\n            normals.buffer,\n            tangents.buffer,\n            uvs.buffer,\n            indices.buffer\n        ]\n    });\n\n};\n"],"names":["vec3","grid","start","right","up","width","height","widthSteps","heightSteps","indices","positions","faceIndex","numVerticesPerFace","offsetVertexIndex","pa","pb","pc","pd","x","y","localQuadIndex","vertexIndex","vertexIndexComponent","triangleIndex","generateFaceGrid","size","radius","resolution","normals","tangents","uvs","uvIndex","position","normal","tangent","bitangent","clamped","sizeHalf","boundMaxVec","boundMinVec","i","indexPos","indexUv","indexTangent","dot","handedness","e","resolve","startTiming","numIndicesPerFace","startVec","rightVec","upVec","sizeVec","duration"],"mappings":"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"}