var F=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});function T(){var t=new F(3);return F!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function R(t){var n=new F(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n}function b(t,n,o){var a=new F(3);return a[0]=t,a[1]=n,a[2]=o,a}function k(t,n,o){return t[0]=n[0]-o[0],t[1]=n[1]-o[1],t[2]=n[2]-o[2],t}function Y(t,n){var o=n[0],a=n[1],i=n[2],f=o*o+a*a+i*i;return f>0&&(f=1/Math.sqrt(f)),t[0]=n[0]*f,t[1]=n[1]*f,t[2]=n[2]*f,t}function S(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function U(t,n,o){var a=n[0],i=n[1],f=n[2],h=o[0],e=o[1],s=o[2];return t[0]=i*s-f*e,t[1]=f*h-a*s,t[2]=a*e-i*h,t}var B=k;(function(){var t=T();return function(n,o,a,i,f,h){var e,s;for(o||(o=3),a||(a=0),i?s=Math.min(i*o+a,n.length):s=n.length,e=a;e<s;e+=o)t[0]=n[e],t[1]=n[e+1],t[2]=n[e+2],f(t,t,h),n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2];return n}})();function E(t,n,o){const a=R(t),i=R(n);Y(a,a),Y(i,i);const f=Math.abs(a[0])<.9?b(1,0,0):b(0,1,0),h=U(T(),a,f);Y(h,h);const e=S(i,h),s=U(T(),h,i),l=S(s,a),r=(Math.atan2(l,e)+Math.PI)/(2*Math.PI),y=Math.round(r*32767)&32767;return(o>0?1:0)<<15|y}function L(t,n,o,a,i,f,h){const e=new Uint16Array(t*8),s=b(1/0,1/0,1/0),l=b(-1/0,-1/0,-1/0);for(let r=0;r<n.length;r+=3)s[0]=Math.min(s[0],n[r]),s[1]=Math.min(s[1],n[r+1]),s[2]=Math.min(s[2],n[r+2]),l[0]=Math.max(l[0],n[r]),l[1]=Math.max(l[1],n[r+1]),l[2]=Math.max(l[2],n[r+2]);const c=B(T(),l,s);for(let r=0;r<t;r++){const y=r*3,x=r*4,M=r*2,u=r*8,g=(n[y]-s[0])/c[0],v=(n[y+1]-s[1])/c[1],p=(n[y+2]-s[2])/c[2];e[u]=g*65535,e[u+1]=v*65535,e[u+2]=p*65535;const q=b(o[y],o[y+1],o[y+2]),D=b(a[x],a[x+1],a[x+2]),C=a[x+3]>0?1:0,w=E(q,D,C);e[u+3]=w;const P=o[y],A=o[y+1],z=o[y+2],I=1/(Math.abs(P)+Math.abs(A)+Math.abs(z));let d=P*I,m=A*I;if(z<0){const V=d;d=(1-Math.abs(m))*(d>=0?1:-1),m=(1-Math.abs(V))*(m>=0?1:-1)}e[u+4]=(d*.5+.5)*65535|0,e[u+5]=(m*.5+.5)*65535|0,e[u+6]=i[M]*65535|0,e[u+7]=i[M+1]*65535|0}return{compressedData:e,positionMin:s,positionMax:l}}self.onmessage=async t=>{const n=performance.now(),{resolution:o,quantize:a}=t.data,i=(o+1)*(o+1),f=new Float32Array(i*3),h=new Float32Array(i*3),e=new Float32Array(i*4),s=new Float32Array(i*2),l=new Uint32Array(o*o*6);let c=0;for(let M=0;M<=o;M++){const u=M*Math.PI/o,g=Math.sin(u),v=Math.cos(u);for(let p=0;p<=o;p++){const q=p*2*Math.PI/o,D=Math.sin(q),w=Math.cos(q)*g,P=v,A=D*g;f[c*3]=w,f[c*3+1]=P,f[c*3+2]=A,h[c*3]=w,h[c*3+1]=P,h[c*3+2]=A;const z=-A,I=0,d=w,m=Math.sqrt(z*z+I*I+d*d);e[c*4]=z/m,e[c*4+1]=I/m,e[c*4+2]=d/m,e[c*4+3]=1,s[c*2]=p/o,s[c*2+1]=M/o,c++}}c=0;for(let M=0;M<o;M++)for(let u=0;u<o;u++){const g=M*(o+1)+u,v=g+o+1;l[c]=g,l[c+1]=v,l[c+2]=g+1,l[c+3]=v,l[c+4]=v+1,l[c+5]=g+1,c+=6}const r={indices:l,vertexBytes:a?16:3*4+3*4+4*4+2*4,numVertices:i};if(a){const{compressedData:M,positionMin:u,positionMax:g}=L(i,f,h,e,s);r.quantizedData=M,r.positionMin=u,r.positionMax=g}else r.positions=f,r.normals=h,r.tangents=e,r.uvs=s;const x=performance.now()-n;console.log(`Sphere generation took ${x.toFixed(2)}ms`),self.postMessage(r,{transfer:[...a?[r.quantizedData.buffer]:[f.buffer,h.buffer,e.buffer,s.buffer],l.buffer]})};
//# sourceMappingURL=sphereWorker-BPiA-VNe.js.map
