var S=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)});function y(){var n=new S(3);return S!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n}function D(n){var t=new S(3);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function M(n,t,o){var s=new S(3);return s[0]=n,s[1]=t,s[2]=o,s}function L(n,t,o){return n[0]=t[0]-o[0],n[1]=t[1]-o[1],n[2]=t[2]-o[2],n}function V(n,t,o){return n[0]=t[0]*o,n[1]=t[1]*o,n[2]=t[2]*o,n}function B(n,t,o,s){return n[0]=t[0]+o[0]*s,n[1]=t[1]+o[1]*s,n[2]=t[2]+o[2]*s,n}function p(n,t){var o=t[0],s=t[1],r=t[2],i=o*o+s*s+r*r;return i>0&&(i=1/Math.sqrt(i)),n[0]=t[0]*i,n[1]=t[1]*i,n[2]=t[2]*i,n}function C(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function w(n,t,o){var s=t[0],r=t[1],i=t[2],d=o[0],e=o[1],l=o[2];return n[0]=r*l-i*e,n[1]=i*d-s*l,n[2]=s*e-r*d,n}var N=L;(function(){var n=y();return function(t,o,s,r,i,d){var e,l;for(o||(o=3),s||(s=0),r?l=Math.min(r*o+s,t.length):l=t.length,e=s;e<l;e+=o)n[0]=t[e],n[1]=t[e+1],n[2]=t[e+2],i(n,n,d),t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2];return t}})();function Y(n,t,o){const s=D(n),r=D(t);p(s,s),p(r,r);const i=Math.abs(s[0])<.9?M(1,0,0):M(0,1,0),d=w(y(),s,i);p(d,d);const e=C(r,d),l=w(y(),d,r),g=C(l,s),c=(Math.atan2(g,e)+Math.PI)/(2*Math.PI),u=Math.round(c*32767)&32767;return(o>0?1:0)<<15|u}function U(n){n=n%(2*Math.PI),n>Math.PI?n-=2*Math.PI:n<-Math.PI&&(n+=2*Math.PI);const t=-.16666667,o=.008333333,s=-198413e-9,r=n*n,i=r*n;return n+t*i+o*i*r+s*i*r*r}function X(n){return U(n+Math.PI/2)}function _(n,t){const o=D(t);p(o,o);const s=n>>15&1,i=(n&32767)/32767*(2*Math.PI)-Math.PI,d=Math.abs(o[0])<.9?M(1,0,0):M(0,1,0),e=w(y(),o,d);p(e,e);const l=X(i),g=U(i),a=y(),c=y();return V(a,e,l),w(c,o,e),B(a,a,c,g),p(a,a),[a,s]}function $(n,t){const o=D(t);p(o,o);const s=n>>15&1,i=(n&32767)/32767*(2*Math.PI)-Math.PI,d=Math.abs(o[0])<.9?M(1,0,0):M(0,1,0),e=w(y(),o,d);p(e,e);const l=Math.cos(i),g=Math.sin(i),a=y(),c=y();return V(a,e,l),w(c,o,e),B(a,a,c,g),p(a,a),[a,s]}function j(n,t,o){const s=Y(n,t,o),[r,i]=$(s,n),[d,e]=_(s,n),l=C(t,r),g=Math.acos(Math.min(1,Math.max(-1,l)));console.log("Encoding test results:"),console.log("Original tangent:",Array.from(t)),console.log("Regular Decoded tangent:",Array.from(r)),console.log("Regular Angle error (radians):",g),console.log("Regular Sign preserved:",o===i);const a=C(t,d),c=Math.acos(Math.min(1,Math.max(-1,a)));console.log("Optimized Decoded tangent:",Array.from(d)),console.log("Optimized Angle error (radians):",c),console.log("Optimized Sign preserved:",o===e)}{const n=M(0,1,0),t=M(1,0,0);j(n,t,1)}function G(n,t,o,s,r,i,d){const e=new Uint16Array(n*8),l=M(1/0,1/0,1/0),g=M(-1/0,-1/0,-1/0);for(let c=0;c<t.length;c+=3)l[0]=Math.min(l[0],t[c]),l[1]=Math.min(l[1],t[c+1]),l[2]=Math.min(l[2],t[c+2]),g[0]=Math.max(g[0],t[c]),g[1]=Math.max(g[1],t[c+1]),g[2]=Math.max(g[2],t[c+2]);const a=N(y(),g,l);for(let c=0;c<n;c++){const u=c*3,I=c*4,f=c*2,h=c*8,m=(t[u]-l[0])/a[0],v=(t[u+1]-l[1])/a[1],P=(t[u+2]-l[2])/a[2];e[h]=m*65535,e[h+1]=v*65535,e[h+2]=P*65535;const F=M(o[u],o[u+1],o[u+2]),E=M(s[I],s[I+1],s[I+2]),R=s[I+3]>0?1:0,O=Y(F,E,R);e[h+3]=O;const T=o[u],x=o[u+1],b=o[u+2],q=1/(Math.abs(T)+Math.abs(x)+Math.abs(b));let A=T*q,z=x*q;if(b<0){const k=A;A=(1-Math.abs(z))*(A>=0?1:-1),z=(1-Math.abs(k))*(z>=0?1:-1)}e[h+4]=(A*.5+.5)*65535|0,e[h+5]=(z*.5+.5)*65535|0,e[h+6]=r[f]*65535|0,e[h+7]=r[f+1]*65535|0}return{compressedData:e,positionMin:l,positionMax:g}}self.onmessage=async n=>{const t=performance.now(),{resolution:o,quantize:s}=n.data,r=(o+1)*(o+1),i=new Float32Array(r*3),d=new Float32Array(r*3),e=new Float32Array(r*4),l=new Float32Array(r*2),g=new Uint32Array(o*o*6);let a=0;for(let f=0;f<=o;f++){const h=f*Math.PI/o,m=Math.sin(h),v=Math.cos(h);for(let P=0;P<=o;P++){const F=P*2*Math.PI/o,E=Math.sin(F),O=Math.cos(F)*m,T=v,x=E*m;i[a*3]=O,i[a*3+1]=T,i[a*3+2]=x,d[a*3]=O,d[a*3+1]=T,d[a*3+2]=x;const b=-x,q=0,A=O,z=Math.sqrt(b*b+q*q+A*A);e[a*4]=b/z,e[a*4+1]=q/z,e[a*4+2]=A/z,e[a*4+3]=1,l[a*2]=P/o,l[a*2+1]=f/o,a++}}a=0;for(let f=0;f<o;f++)for(let h=0;h<o;h++){const m=f*(o+1)+h,v=m+o+1;g[a]=m,g[a+1]=v,g[a+2]=m+1,g[a+3]=v,g[a+4]=v+1,g[a+5]=m+1,a+=6}const c={indices:g,vertexBytes:s?16:3*4+3*4+4*4+2*4,numVertices:r};if(s){const{compressedData:f,positionMin:h,positionMax:m}=G(r,i,d,e,l);c.quantizedData=f,c.positionMin=h,c.positionMax=m}else c.positions=i,c.normals=d,c.tangents=e,c.uvs=l;const I=performance.now()-t;console.log(`Sphere generation took ${I.toFixed(2)}ms`),self.postMessage(c,{transfer:[...s?[c.quantizedData.buffer]:[i.buffer,d.buffer,e.buffer,l.buffer],g.buffer]})};
//# sourceMappingURL=sphereWorker-CHPrLTr0.js.map
