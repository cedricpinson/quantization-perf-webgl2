{"version":3,"file":"wavySphereWorker-7LgYWHM_.js","sources":["../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/vec3.js","../src/tangentEncoding.ts","../src/quantize.ts","../src/wavySphereWorker.ts"],"sourcesContent":["/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import { vec3 } from 'gl-matrix';\n\n/**\n * Encodes a tangent vector into a 16-bit value using normal and tangent vectors\n * Returns a 16-bit number where:\n * - Bits 0-14: Quantized angle (15 bits)\n * - Bit 15: Tangent sign (1 bit)\n */\nexport function encodeTangent(\n    normal: vec3,\n    tangent: vec3,\n    tangentSign: number\n): number {\n    // Create copies to avoid modifying input vectors\n    const normalCopy = vec3.clone(normal);\n    const tangentCopy = vec3.clone(tangent);\n\n    // Ensure vectors are normalized\n    vec3.normalize(normalCopy, normalCopy);\n    vec3.normalize(tangentCopy, tangentCopy);\n\n    // Calculate initial bitangent\n    const tempVec = Math.abs(normalCopy[0]) < 0.9 ?\n        vec3.fromValues(1, 0, 0) :\n        vec3.fromValues(0, 1, 0);\n    const bitangent = vec3.cross(vec3.create(), normalCopy, tempVec);\n    vec3.normalize(bitangent, bitangent);\n\n    // Calculate angle between tangent and bitangent\n    const cosAngle = vec3.dot(tangentCopy, bitangent);\n    const crossProduct = vec3.cross(vec3.create(), bitangent, tangentCopy);\n    const sinAngle = vec3.dot(crossProduct, normalCopy);\n    const angle = Math.atan2(sinAngle, cosAngle);\n\n    // Normalize angle to [0,1] range\n    const normalizedAngle = (angle + Math.PI) / (2 * Math.PI);\n\n    // Quantize to 15 bits (0-32767)\n    const quantizedAngle = Math.round(normalizedAngle * 32767) & 0x7FFF;\n\n    // Combine with sign bit\n    const sign = tangentSign > 0 ? 1 : 0;\n    return (sign << 15) | quantizedAngle;\n}\n\n/**\n * Fast polynomial approximation for sine\n * Max error < 0.001 for range [-π, π]\n */\nfunction fastSin(x: number): number {\n    // Wrap x to [-π, π]\n    x = x % (2 * Math.PI);\n    if (x > Math.PI) x -= 2 * Math.PI;\n    else if (x < -Math.PI) x += 2 * Math.PI;\n\n    // Coefficients for polynomial approximation\n    const a3 = -0.16666667;  // -1/6\n    const a5 = 0.008333333;  // 1/120\n    const a7 = -0.000198413; // -1/5040\n\n    const x2 = x * x;\n    const x3 = x2 * x;\n\n    return x + a3 * x3 + a5 * x3 * x2 + a7 * x3 * x2 * x2;\n}\n\n/**\n * Fast polynomial approximation for cosine using sin(x + π/2)\n * Max error < 0.001 for range [-π, π]\n */\nfunction fastCos(x: number): number {\n    return fastSin(x + Math.PI / 2);\n}\n\n/**\n * Optimized tangent decoder using polynomial approximations\n */\nexport function decodeTangentOptimized(\n    encoded: number,\n    normal: vec3\n): [vec3, number] {\n    // Create a copy of the normal\n    const normalCopy = vec3.clone(normal);\n    vec3.normalize(normalCopy, normalCopy);\n\n    // Extract sign and angle\n    const sign = (encoded >> 15) & 1;\n    const quantizedAngle = encoded & 0x7FFF;\n\n    // Convert back to radians\n    const angle = (quantizedAngle / 32767) * (2 * Math.PI) - Math.PI;\n\n    // Calculate initial bitangent\n    const tempVec = Math.abs(normalCopy[0]) < 0.9 ?\n        vec3.fromValues(1, 0, 0) :\n        vec3.fromValues(0, 1, 0);\n    const bitangent = vec3.cross(vec3.create(), normalCopy, tempVec);\n    vec3.normalize(bitangent, bitangent);\n\n    // Get sine and cosine values using polynomial approximation\n    const cosAngle = fastCos(angle);\n    const sinAngle = fastSin(angle);\n\n    // Rotate bitangent around normal\n    const tangent = vec3.create();\n    const rotatedBitangent = vec3.create();\n    vec3.scale(tangent, bitangent, cosAngle);\n    vec3.cross(rotatedBitangent, normalCopy, bitangent);\n    vec3.scaleAndAdd(tangent, tangent, rotatedBitangent, sinAngle);\n    vec3.normalize(tangent, tangent);\n\n    return [tangent, sign];\n}\n\n/**\n * Optimized tangent decoder using polynomial approximations\n */\nexport function decodeTangentOriginal(\n    encoded: number,\n    normal: vec3\n): [vec3, number] {\n    // Create a copy of the normal\n    const normalCopy = vec3.clone(normal);\n    vec3.normalize(normalCopy, normalCopy);\n\n    // Extract sign and angle\n    const sign = (encoded >> 15) & 1;\n    const quantizedAngle = encoded & 0x7FFF;\n\n    // Convert back to radians\n    const angle = (quantizedAngle / 32767) * (2 * Math.PI) - Math.PI;\n\n    // Calculate initial bitangent\n    const tempVec = Math.abs(normalCopy[0]) < 0.9 ?\n        vec3.fromValues(1, 0, 0) :\n        vec3.fromValues(0, 1, 0);\n    const bitangent = vec3.cross(vec3.create(), normalCopy, tempVec);\n    vec3.normalize(bitangent, bitangent);\n\n    // Get sine and cosine values using polynomial approximation\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n\n    // Rotate bitangent around normal\n    const tangent = vec3.create();\n    const rotatedBitangent = vec3.create();\n    vec3.scale(tangent, bitangent, cosAngle);\n    vec3.cross(rotatedBitangent, normalCopy, bitangent);\n    vec3.scaleAndAdd(tangent, tangent, rotatedBitangent, sinAngle);\n    vec3.normalize(tangent, tangent);\n\n    return [tangent, sign];\n}\n\n// Test function to verify encoding/decoding\nexport function testTangentEncoding(\n    normal: vec3,\n    tangent: vec3,\n    originalSign: number\n): void {\n    // Encode\n    const encoded = encodeTangent(normal, tangent, originalSign);\n\n    // Decode\n    const [decodedTangent, decodedSign] = decodeTangentOriginal(encoded, normal);\n    const [decodedTangentOptimized, decodedSignOptimized] = decodeTangentOptimized(encoded, normal);\n\n    // Calculate error\n    const dotProduct = vec3.dot(tangent, decodedTangent);\n    const angleError = Math.acos(Math.min(1, Math.max(-1, dotProduct)));\n\n    console.log('Encoding test results:');\n    console.log('Original tangent:', Array.from(tangent));\n    console.log('Regular Decoded tangent:', Array.from(decodedTangent));\n    console.log('Regular Angle error (radians):', angleError);\n    console.log('Regular Sign preserved:', originalSign === decodedSign);\n\n    const dotProductOptimized = vec3.dot(tangent, decodedTangentOptimized);\n    const angleErrorOptimized = Math.acos(Math.min(1, Math.max(-1, dotProductOptimized)));\n\n    console.log('Optimized Decoded tangent:', Array.from(decodedTangentOptimized));\n    console.log('Optimized Angle error (radians):', angleErrorOptimized);\n    console.log('Optimized Sign preserved:', originalSign === decodedSignOptimized);\n}\n\nif (true) {\n    // Example usage\n    const normal = vec3.fromValues(0, 1, 0);\n    const tangent = vec3.fromValues(1, 0, 0);\n    const originalSign = 1;\n\n    // Test the encoding/decoding\n    testTangentEncoding(normal, tangent, originalSign);\n\n    // Or use encode/decode directly\n    // @ts-ignore\n    // const encoded = encodeTangent(normal, tangent, originalSign);\n    // // @ts-ignore\n    // const [decodedTangent, decodedSign] = decodeTangentOptimized(encoded, normal);\n}","import { vec3 } from 'gl-matrix';\nimport { encodeTangent } from './tangentEncoding';\n\nexport interface QuantizedMesh {\n    compressedData: Uint16Array;\n    indices: Uint32Array;\n    positionMin: vec3;\n    positionMax: vec3;\n    vertexBytes: number;\n}\n\n// - Positions: 3x16bits (quantized on mesh bounding box)\n// - Normals: 2x16bits (octahedral encoding)\n// - Tangents: 1x16bits (1 bit sign + 15 bits angle)\n// - UVs: 2x16bits (quantized 0-1 range)\n\n// Total: 8x16bits per vertex (16 bytes) vs 48 bytes for uncompressed format\nexport function quantizeMesh(numVertices: number, positions: Float32Array, normals: Float32Array, tangents: Float32Array, uvs: Float32Array, min: vec3 | null, max: vec3 | null): { compressedData: Uint16Array, positionMin: vec3, positionMax: vec3 } {\n    const compressedData = new Uint16Array(numVertices * 8); // 4 vec2 per vertex or 8x16bits\n\n    const positionMin = vec3.fromValues(Infinity, Infinity, Infinity);\n    const positionMax = vec3.fromValues(-Infinity, -Infinity, -Infinity);\n    if (!min || !max) {\n        // Find position bounds\n        for (let i = 0; i < positions.length; i += 3) {\n            positionMin[0] = Math.min(positionMin[0], positions[i]);\n            positionMin[1] = Math.min(positionMin[1], positions[i + 1]);\n            positionMin[2] = Math.min(positionMin[2], positions[i + 2]);\n            positionMax[0] = Math.max(positionMax[0], positions[i]);\n            positionMax[1] = Math.max(positionMax[1], positions[i + 1]);\n            positionMax[2] = Math.max(positionMax[2], positions[i + 2]);\n        }\n    } else {\n        vec3.copy(positionMin, min);\n        vec3.copy(positionMax, max);\n    }\n    // Quantize positions to 16 bits\n    const range = vec3.sub(vec3.create(), positionMax, positionMin);\n    for (let i = 0; i < numVertices; i++) {\n        const posIdx = i * 3;\n        const tanIdx = i * 4;\n        const uvIdx = i * 2;\n        const outIdx = i * 8;\n\n        // Quantize positions to 16 bits\n        const px = (positions[posIdx] - positionMin[0]) / range[0];\n        const py = (positions[posIdx + 1] - positionMin[1]) / range[1];\n        const pz = (positions[posIdx + 2] - positionMin[2]) / range[2];\n\n        compressedData[outIdx] = px * 65535;\n        compressedData[outIdx + 1] = py * 65535;\n\n        // Encode position.z and tangent angle+sign\n        compressedData[outIdx + 2] = pz * 65535;\n\n        // Calculate tangent angle\n        const normal = vec3.fromValues(normals[posIdx], normals[posIdx + 1], normals[posIdx + 2]);\n        const tangent = vec3.fromValues(tangents[tanIdx], tangents[tanIdx + 1], tangents[tanIdx + 2]);\n        const tangentSign = tangents[tanIdx + 3] > 0 ? 1 : 0;\n\n        const encodedTangent = encodeTangent(normal, tangent, tangentSign);\n        //const decodedTangent = decodeTangent(encodedTangent, normal);\n\n        compressedData[outIdx + 3] = encodedTangent;\n\n        // Encode normal using octahedral encoding\n        const nx = normals[posIdx];\n        const ny = normals[posIdx + 1];\n        const nz = normals[posIdx + 2];\n        const invL1Norm = 1 / (Math.abs(nx) + Math.abs(ny) + Math.abs(nz));\n\n        let octX = nx * invL1Norm;\n        let octY = ny * invL1Norm;\n\n        if (nz < 0) {\n            const temp = octX;\n            octX = (1 - Math.abs(octY)) * (octX >= 0 ? 1 : -1);\n            octY = (1 - Math.abs(temp)) * (octY >= 0 ? 1 : -1);\n        }\n\n        compressedData[outIdx + 4] = ((octX * 0.5 + 0.5) * 65535) | 0;\n        compressedData[outIdx + 5] = ((octY * 0.5 + 0.5) * 65535) | 0;\n\n        // Quantize UVs to 16 bits\n        compressedData[outIdx + 6] = (uvs[uvIdx] * 65535) | 0;\n        compressedData[outIdx + 7] = (uvs[uvIdx + 1] * 65535) | 0;\n    }\n\n    return {\n        compressedData,\n        positionMin,\n        positionMax,\n    };\n}","import { quantizeMesh } from './quantize';\ninterface WavySphereData {\n    resolution: number;\n    quantize: boolean;\n}\n\n// Import quantizeMesh dynamically to ensure it's loaded before use\nself.onmessage = async (e: MessageEvent<WavySphereData>) => {\n    const start = performance.now();\n    const { resolution, quantize } = e.data;\n\n    const numVertices = (resolution + 1) * (resolution + 1);\n    const positions = new Float32Array(numVertices * 3);\n    const normals = new Float32Array(numVertices * 3);\n    const tangents = new Float32Array(numVertices * 4);\n    const uvs = new Float32Array(numVertices * 2);\n    const indices = new Uint32Array(resolution * resolution * 6);\n\n    const waves = 8;  // Number of waves\n    const amplitude = 0.2;  // Wave height\n\n    let index = 0;\n    for (let lat = 0; lat <= resolution; lat++) {\n        const theta = (lat * Math.PI) / resolution;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n\n        for (let lon = 0; lon <= resolution; lon++) {\n            const phi = (lon * 2 * Math.PI) / resolution;\n            const sinPhi = Math.sin(phi);\n            const cosPhi = Math.cos(phi);\n\n            // Add wavy displacement\n            const wave = 1 + amplitude * Math.sin(waves * phi) * Math.sin(waves * theta);\n\n            // Position\n            const x = cosPhi * sinTheta * wave;\n            const y = cosTheta * wave;\n            const z = sinPhi * sinTheta * wave;\n\n            positions[index * 3] = x;\n            positions[index * 3 + 1] = y;\n            positions[index * 3 + 2] = z;\n\n            // Calculate normal (more complex due to displacement)\n            const nx = cosPhi * sinTheta;\n            const ny = cosTheta;\n            const nz = sinPhi * sinTheta;\n            const nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n            normals[index * 3] = nx / nl;\n            normals[index * 3 + 1] = ny / nl;\n            normals[index * 3 + 2] = nz / nl;\n\n            // Tangent\n            const tx = -z;\n            const ty = 0;\n            const tz = x;\n            const tl = Math.sqrt(tx * tx + ty * ty + tz * tz);\n            tangents[index * 4] = tx / tl;\n            tangents[index * 4 + 1] = ty / tl;\n            tangents[index * 4 + 2] = tz / tl;\n            tangents[index * 4 + 3] = 1.0;\n\n            uvs[index * 2] = lon / resolution;\n            uvs[index * 2 + 1] = lat / resolution;\n            index++;\n        }\n    }\n\n    // Generate indices\n    index = 0;\n    for (let lat = 0; lat < resolution; lat++) {\n        for (let lon = 0; lon < resolution; lon++) {\n            const first = lat * (resolution + 1) + lon;\n            const second = first + resolution + 1;\n            indices[index] = first;\n            indices[index + 1] = second;\n            indices[index + 2] = first + 1;\n            indices[index + 3] = second;\n            indices[index + 4] = second + 1;\n            indices[index + 5] = first + 1;\n            index += 6;\n        }\n    }\n\n    const result: any = {\n        indices,\n        vertexBytes: quantize ? 16 : 3 * 4 + 3 * 4 + 4 * 4 + 2 * 4,\n        numVertices\n    };\n\n    if (quantize) {\n        const { compressedData, positionMin, positionMax } = quantizeMesh(numVertices, positions, normals, tangents, uvs, null, null);\n        result.quantizedData = compressedData;\n        result.positionMin = positionMin;\n        result.positionMax = positionMax;\n    } else {\n        result.positions = positions;\n        result.normals = normals;\n        result.tangents = tangents;\n        result.uvs = uvs;\n    }\n\n    const end = performance.now();\n    const duration = end - start;\n    console.log(`Wavy sphere generation took ${duration.toFixed(2)}ms`);\n\n    self.postMessage(result, {\n        transfer: [\n            ...(quantize ? [result.quantizedData.buffer, indices.buffer] : [positions.buffer, normals.buffer, tangents.buffer, uvs.buffer, indices.buffer]),\n        ]\n    });\n};\n"],"names":["ARRAY_TYPE","y","i","create","out","glMatrix.ARRAY_TYPE","clone","a","fromValues","x","z","subtract","b","scale","scaleAndAdd","normalize","len","dot","cross","ax","ay","az","bx","by","bz","sub","vec","stride","offset","count","fn","arg","l","encodeTangent","normal","tangent","tangentSign","normalCopy","vec3.clone","tangentCopy","vec3.normalize","tempVec","vec3.fromValues","bitangent","vec3.cross","vec3.create","cosAngle","vec3.dot","crossProduct","sinAngle","normalizedAngle","quantizedAngle","fastSin","a3","a5","a7","x2","x3","fastCos","decodeTangentOptimized","encoded","sign","angle","rotatedBitangent","vec3.scale","vec3.scaleAndAdd","decodeTangentOriginal","testTangentEncoding","originalSign","decodedTangent","decodedSign","decodedTangentOptimized","decodedSignOptimized","dotProduct","angleError","dotProductOptimized","angleErrorOptimized","quantizeMesh","numVertices","positions","normals","tangents","uvs","min","max","compressedData","positionMin","positionMax","range","vec3.sub","posIdx","tanIdx","uvIdx","outIdx","px","py","pz","encodedTangent","nx","ny","nz","invL1Norm","octX","octY","temp","e","start","resolution","quantize","indices","waves","amplitude","index","lat","theta","sinTheta","cosTheta","lon","phi","sinPhi","cosPhi","wave","nl","tx","ty","tz","tl","first","second","result","duration"],"mappings":"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","x_google_ignoreList":[0,1]}